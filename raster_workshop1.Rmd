---
title: "EDS Raster workshop"
author: "Casey O'Hara"
date: "11/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, messages = FALSE, warnings = FALSE)

### load packages.  Since raster has a "select" function but we more often
### use the tidyverse::select, load raster first, and let tidyverse overwrite
### that function.

library(raster)
library(tidyverse)
library(sf)
library(fasterize)
library(here)
```

Session outline:

- make a cell ID raster from scratch, using extent and CRS of an EEZ polygon, assign numeric cell IDs.
    - note similarities and differences to Mike's workshop
    - writeRaster
- write a function to take a raster and a polygon and plot them together
- rasterize the EEZ polygon to create a mask.
- use rasterFromXYZ to rasterize a dataframe of AquaMaps cell IDs
- projectRaster from an existing raster (AquaMaps cell IDs) to the new CRS, resolution, and extent
- use subs to assign values from a single species into the cell IDs
- plot it
- use tidyverse to create a species richness dataframe
- use subs again, then mask it to the EEZ

- raster math
- calc
- reclassify
- zonal

- values to create a dataframe

``` {r}
### Read a truncated version of the AquaMaps Half-degree Cell
### Authority File (HCAF) - cell IDs, locations, ocean area, in a dataframe
hcaf_df <- read_csv(here('_data/am_hcaf.csv'))

### View the dataframe - note the different columns included in it.
### LOICZID is "Land Ocean Interactions in the Coastal Zone" cell ID, but
### really just a unique number for each cell.

### create an xyz dataframe for the raster::rasterFromXYZ function.  Use
### loiczid as cell value.
xyz_df <- hcaf_df %>%
  select(x = center_long, y = center_lat, z = loiczid)

hcaf_rast <- raster::rasterFromXYZ(xyz_df)
crs(hcaf_rast) ### oh noes, it's NA, that's no good! set it:
crs(hcaf_rast) <- '+init=epsg:4326'   
  ### or '+proj=longlat +datum=WGS84 +no_defs', same thing

hcaf_rast ### look at the basic info about the raster

plot(hcaf_rast)

writeRaster(hcaf_rast, here('_spatial/hcaf_rast.tif'), overwrite = TRUE)
```

```{r manually create the same raster from scratch}
hcaf_rast2 <- raster(xmn = -180, xmx = 180, ymn = -90, ymx = 90,
                     res = 0.5,
                     crs = '+init=epsg:4326')
values(hcaf_rast2) <- 1:ncell(hcaf_rast2)
### NOTE: if you saw the previous gridded climate data workshop, Mike created
### a raster from scratch using a matrix - this filled the values in columns
### (top to bottom), then left to right by column.  This method fills the
### values by row (left to right), then top-to-bottom row by row.
### Which is better?  both are totally arbitrary - use the method that works
### for you (or in this case, matches the dataset you're working with)

hcaf_rast   ### check the parameters of the original one
hcaf_rast2  ### check the parameters of the new one

### check to see whether the two rasters are identical
raster::compareRaster(hcaf_rast, hcaf_rast2, values = TRUE)

### no need to save, we already have one that works just fine...
```

```{r examine ocean area by cell}
ocean_area_df <- hcaf_df %>%
  mutate(pct_ocean = ocean_area / cell_area)

### use raster::subs() to substitute in values to replace others
pct_ocean_rast <- subs(hcaf_rast, ocean_area_df,
                       by = 'loiczid', ### which variable is the key
                       which = 'pct_ocean') ### which var is the new value

pct_ocean_rast
plot(pct_ocean_rast)

writeRaster(pct_ocean_rast, here('_spatial/ocean_rast.tif'),
            overwrite = TRUE)
```

Load and examine the AquaMaps information on sharks:

* taxonomic information on sharks found in the region
* a lookup table that maps shark species IDs to cell IDs
* NOTE: these are trimmed down from the full AquaMaps dataset for size, so they don't fill up the whole map, and only include shark species.

``` {r load shark species data and cell info}
### taxonomic info on shark species within southeastern Africa EEZs
am_spp_info <- read_csv(here('_data/am_shark_info.csv'))
### species ID to cell probability lookup table - maps species to cells
am_spp_cells <- read_csv(here('_data/am_shark_cells.csv'))
```

```{r use subs to examine the range for scalloped hammerhead}
### View am_spp_info and search to find ID for "scalloped hammerhead"
hh_id <- 'Fis-23273'
hh_cells_df <- am_spp_cells %>%
  filter(am_sid == hh_id)

### use raster::subs() to substitute in values for others
hh_range_rast <- subs(hcaf_rast, hh_cells_df,
                      by = 'loiczid', ### which variable is the key
                      which = 'prob') ### which var is the new value
plot(hh_range_rast)

### that's way more map space than we need!  raster::trim() can trim it to remove
### the whitespace
hh_range_rast <- hh_range_rast %>%
  raster::trim()

hh_range_rast
plot(hh_range_rast)
writeRaster(hh_range_rast, here('_spatial/hammerhead_rast_hcaf.tif'),
            overwrite = TRUE)
```


Let's use the Mozambique preferred CRS instead of generic WGS84 lat-long.  We will create a new base raster for analysis, at a 10 km resolution equal area, in the same CRS as provided by WCS.

``` {r}
se_afr_eez_sf <- read_sf(here('_spatial/moz_eez', 
                              'Mozambique_EEZ_WGS_84_NSIDC_EASE_Grid_2_0_Global.shp'))
# crs(se_afr_eez_sf) 
# [1] "+proj=cea +lat_ts=30 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
# crs(hcaf_rast) 
# CRS arguments: +proj=longlat +datum=WGS84 +no_defs

### First, trim the global hcaf raster down to the same extent as our range map
hcaf_rast_crop <- raster::crop(hcaf_rast, hh_range_rast)

### Next use raster::projectRaster to change the CRS and resolution
hcaf_rast_reproj <- projectRaster(hcaf_rast_crop, 
                                  method = 'ngb',
                                  crs = crs(se_afr_eez_sf),
                                  res = 10000)
# hcaf_rast_crop
# hcaf_rast_reproj
plot(hcaf_rast_reproj)
```

And important understanding: we've reprojected half-degree cells, each with a unique ID, to 10 km x 10 km cells.  These new cells are smaller, but still contain the same cell ID as the original larger cell, because we used "nearest neighbor" i.e., `method = "ngb"`.  This means that there are multiple cells at the finer resolution to make up the same area as the larger cells at the coarser resolution.

```{r}
values_lo_res <- values(hcaf_rast_crop)
### make a table of number of cells for each values; use 'head()' just to see 
### the first 20 instances
table(values_lo_res) %>% head(20)
### one cell per cell ID value

values_hi_res <- values(hcaf_rast_reproj)
table(values_hi_res) %>% head(20)
### between 24 and 30 cells per cell ID value
```


``` {r}
### Let's transform the hammerhead range to the Mozambique CRS.
### could do either of these:
### * projectRaster() from half-degree cells to 10 km cells
### * subs() into the new projected hcaf 10 km cell raster, using the cell IDs
hh_range_reproj <- subs(hcaf_rast_reproj, hh_cells_df, 
                        by = 'loiczid', which = 'prob')

### plot this using ggplot, and add the EEZ layer on top.  First,
### need to turn the raster into a dataframe...
hh_range_df <- raster::rasterToPoints(hh_range_reproj) %>%
  as.data.frame()

ggplot() +
  geom_raster(data = hh_range_df, aes(x, y, fill = prob)) +
  geom_sf(data = se_afr_eez_sf, color = 'red', fill = NA)

```

``` {r plot_rast utility function}
### The above lines of code to plot the raster with the sf 
### are coded into a function here, for future ease of use:
plot_rast <- function(rast, sf) {
  ### function to plot a raster with a simple features border overlaid
  
  ### error check: make sure CRS are equal
  if(as.character(crs(rast)) != crs(sf)) {
    error_msg <- sprintf('CRS mismatch!\n    raster: %s\n    sf: %s',
                         as.character(crs(rast)), crs(sf))
    stop(error_msg) ### stops everything and communicates an error
  }
  
  fill_name <- names(rast)
  ### convert raster to points
  rast_df <- rasterToPoints(rast) %>%
    as.data.frame() %>%
    setNames(c('x', 'y', 'z'))
  
  ### ggplot the raster points and the simple features
  x <- ggplot() +
    geom_raster(data = rast_df, aes(x, y, fill = z)) +
    geom_sf(data = sf, color = 'red', fill = NA) +
    labs(fill = fill_name)
  
  return(x)
}

plot_rast(hh_range_reproj, se_afr_eez_sf)
```
Note that the square cells don't line up well with the smoother coastline...

Let's make a mask of just the Mozambique EEZ, and clip this regional raster down to just that.  We will use `fasterize::fasterize()`, but could also do with `raster::rasterize()`.  `rasterize()` used to have some bugs in it, and may still, so I tend to prefer `fasterize()`.  

NOTE: `fasterize()` works with simple features `sf` objects and converts them to rasters based on a raster template you provide.

```{r}
se_afr_eez_df <- se_afr_eez_sf %>%
  as.data.frame() %>%
  select(-geometry)
moz_eez_sf <- se_afr_eez_sf %>%
  filter(ISO_Ter1 == 'MOZ')

### default is to convert any cells that fall within a polygon to a value
### of 1.  Here that's OK, but later we will set the "field" argument to
### choose how to determine the cell values
moz_eez_rast <- fasterize(moz_eez_sf, hcaf_rast_reproj)

plot_rast(moz_eez_rast, moz_eez_sf)

### Use mask to keep only cells that occur in (i.e., non-NA) the moz_eez_rast
hh_range_moz <- raster::mask(hh_range_reproj, moz_eez_rast)

plot_rast(hh_range_moz, moz_eez_sf)
```

Let's make a species richness map, counting how many species can be found in each cell.  To do this, we can use the dataframe of shark species to cells, `am_spp_cells`.  For each cell, we can count up how many distinct species IDs occur.

Note: this ignores probability - so even 1% probability is counted... but that's easy to fix!
``` {r species richness map}
### map out the shark species richness
shark_richness_df <- am_spp_cells %>%
  group_by(loiczid) %>%
  summarize(n_sharks = n_distinct(am_sid))

shark_richness_rast <- raster::subs(hcaf_rast_reproj, shark_richness_df, 
                                    by = 'loiczid', which = 'n_sharks')
plot_rast(shark_richness_rast, moz_eez_sf)
```

Review: what have we done so far?

* created a raster from evenly-spaced lat-long data
* created a raster from scratch using an extent/bounding box (xmin, xmax, ymin, ymax) and resolution
* added a coordinate reference system to a raster, and checked it.
* used `raster::subs()` to substitute desired values into a raster, replacing cell ID values
* plotted a raster quickly using base plotting
* used `raster::trim()` to remove excess NA values from a raster
* used `raster::projectRaster()` to reproject an existing raster to the parameters (extent, origin, resolution, CRS) of a different raster
* plotted a raster using `ggplot2::geom_raster()` by converting the raster to a dataframe
* plotted a simple features polygon on top of the raster using `ggplot2::geom_sf()`


More examples for other parts of workshop

```
### distance raster example
dist_rast <- raster::distance(se_afr_eez_6933_rast)
plot(dist_rast)

### cell ID example
cell_id_rast <- se_afr_eez_6933_rast ### initialize it with a raster with the right resolution, CRS, and extent
values(cell_id_rast) <- 1:ncell(cell_id_rast) ### put in unique numbers for cell values
plot(cell_id_rast)

### raster to polygon example
hcaf_moz_poly <- raster::rasterToPolygons(hcaf_moz_rast, dissolve = FALSE)
se_afr_eez_poly <- raster::rasterToPolygons(se_afr_eez_rast, dissolve = TRUE)
plot(se_afr_eez_poly)
```

